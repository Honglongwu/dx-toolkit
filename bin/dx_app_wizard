#!/usr/bin/env python

import sys, os, subprocess
import textwrap
import json
from optparse import OptionParser

API_VERSION = '1.0.0'

CYAN = '\033[36m'
BLUE = '\033[34m'
YELLOW = '\033[33m'
GREEN = '\033[32m'
RED = '\033[31m'
BOLD = '\033[1m'
ENDC = '\033[0m'

USING_COMPLETER = False
manifest = []

class Completer():
    def __init__(self, choices):
        self.matches = None
        self.choices = choices

    def __call__(self, text, state):
        if state == 0:
            self.matches = filter(lambda choice: choice.startswith(text),
                                  self.choices)

        if self.matches is not None and state < len(self.matches):
            return self.matches[state]
        else:
            return None

try:
    import readline
    import rlcompleter
    readline.parse_and_bind("tab: complete")
    readline.set_completer_delims("")
    USING_COMPLETER = True
except ImportError:
    print 'NOTE: readline module not available.  Install for tab-completion.'

def use_completer(completer=None):
    if USING_COMPLETER:
        readline.set_completer(completer)

# Expect default to be a default string value
# Expect choices to be a list of strings
def prompt_for_var(prompt_str, default=None, allow_empty=False, choices=None):
    prompt = prompt_str
    if default is not None:
        prompt += ' [' + default + ']: '
    else:
        prompt += ': '
    while True:
        try: 
            value = raw_input(prompt)
        except KeyboardInterrupt:
            print ''
            continue
        except EOFError:
            print ''
            exit(1)
        if value != '':
            if choices is not None and value not in choices:
                print 'Error: unrecognized response, expected one of ' + json.dumps(choices)
            else:
                return value
        elif default is not None:
            return default
        elif allow_empty:
            return value

def prompt_for_yn(prompt_str, default=None):
    if default == True:
        prompt = prompt_str + ' [Y/n]: '
    elif default == False:
        prompt = prompt_str + ' [y/N]: '
    else:
        prompt = prompt_str + ' [y/n]: '

    while True:
        try:
            value = raw_input(prompt)
        except KeyboardInterrupt:
            print ''
            continue
        except EOFError:
            print ''
            exit(1)
        if value != '':
            if value.lower()[0] == 'y':
                return True
            elif value.lower()[0] == 'n':
                return False
            else:
                print 'Error: unrecognized response'
        elif default is not None:
            return default

parser = OptionParser(usage="%prog [options] program_dir", description="Create a source code directory for a DNAnexus program/app.")
parser.add_option("-f", "--overwrite", help="Overwrite files that are in the way", action='store_true', default=False)
(opts, args) = parser.parse_args()

print 'DNAne' + CYAN + BOLD + 'x' + ENDC + 'us App Wizard, API v' + API_VERSION
print ''

print BOLD + 'Basic Metadata' + ENDC
print ''
print textwrap.fill('''Please enter basic metadata fields that will be used to
describe your program/app.  Optional fields are denoted by options with square
brackets.  At the end of this wizard, the files necessary for building your
program or app will be generated from the answers you provide.''')
print ''

name = prompt_for_var('Program/App Name')

#if os.path.exists(name) and not opts.overwrite:
#    sys.stderr.write('''The directory %s already exists, please specify the --overwrite option to overwrite files in it.''' % name)
if os.path.exists(name):
    sys.stderr.write('''The directory %s already exists, please move it or specify a different name.\n''' % name)
    sys.exit(1)

try:
    os.mkdir(name)
except:
    sys.stderr.write('''Unable to create a directory for %s, please check that it is a valid program name and the
working directory exists and is writable.\n''' % name)
    sys.exit(1)

title = prompt_for_var('Title', '')
summary = prompt_for_var('Summary', '')
description = prompt_for_var('Description', '')
print 'Setting API version to ' + API_VERSION
version = prompt_for_var('Version', '0.0.1')

interpreter_choices = ['python2.7']
use_completer(Completer(interpreter_choices))
interpreter = prompt_for_var('Interpreter', 'python2.7', interpreter_choices)
use_completer()

program_json = {
    "name": name,
    "dxapi": API_VERSION,
    "runSpec": {"interpreter": interpreter}
}

if title != '':
    program_json["title"] = title
if summary != '':
    program_json['summary'] = summary
if description != '':
    program_json['description'] = description

app_json = {
    "version": version,
    "details": {
        "contactUrl": "http://develop.dnanexus.com/Apps/" + name
    }
}

class_completer = Completer(['int', 'float', 'string', 'boolean', 'hash',
                             'array:int', 'array:float', 'array:string', 'array:boolean', 'array:hash',
                             'record', 'file', 'gtable', 'table', 'program',
                             'array:record', 'array:file', 'array:gtable', 'array:table', 'array:program'])

print ''
print BOLD + 'Input Specification' + ENDC
print ''
print textwrap.fill('Specifying the inputs to your program is optional but is required if you would like to publish it as an app.')
print ''

input_spec = prompt_for_yn('Specify inputs', True)
if input_spec:
    program_json['inputSpec'] = []
    print ''
    print textwrap.fill('You will now be prompted for each input parameter to your program.  Each parameter should have a unique name that is valid as a variable name in your programming language of choice.')

    while True:
        print ''
        input_name = prompt_for_var('Variable name (leave empty to finish entering input parameters)', allow_empty=True)
        if input_name == '':
            break
        input_label = prompt_for_var('Label', '')

        use_completer(class_completer)
        print 'Your input variable must be of one of the following classes:'
        print '''array:boolean  array:hash     array:string   float          program
array:file     array:int      array:table    gtable         record
array:float    array:program  boolean        hash           string
array:gtable   array:record   file           int            table
'''
        input_class = prompt_for_var('Choose a class')
        use_completer()

        optional = prompt_for_yn('This is an optional parameter')

        default_val = None
        if optional and input_class in ['int', 'float', 'string', 'boolean']:
            default_val = prompt_for_yn('A default value should be provided')
            if default_val:
                if input_class == 'boolean':
                    default_val = prompt_for_var('  Default value', None, ['true', 'false'])
                else:
                    default_val = prompt_for_var('  Default value')

                if input_class == 'boolean':
                    default_val = (default_val == 'true')
                elif input_class == 'int':
                    default_val = int(default_val)
                elif input_class == 'float':
                    default_val = float(default_val)
            else:
                default_val = None

        # Fill in the input parameter's JSON
        parameter_json = {
            "name": input_name,
            "class": input_class,
            "optional": optional
            }
        if input_label != '':
            parameter_json['label'] = input_label
        if default_val is not None:
            parameter_json['default'] = default_val
        program_json['inputSpec'].append(parameter_json)

print ''
print BOLD + 'Output Specification' + ENDC
print ''
print textwrap.fill('Specifying the outputs to your program is optional but is required if you would like to publish it as an app.')
print ''

output_spec = prompt_for_yn('Specify outputs', True)
if output_spec:
    program_json['outputSpec'] = []
    print ''
    print textwrap.fill('You will now be prompted for each output parameter of your program.')

    while True:
        print ''
        output_name = prompt_for_var('Variable name (leave empty to finish entering output parameters)', allow_empty=True)
        if output_name == '':
            break
        output_label = prompt_for_var('Label (optional)', '')

        use_completer(class_completer)
        print 'Your input variable must be of one of the following classes:'
        print '''array:boolean  array:hash     array:string   float          program
array:file     array:int      array:table    gtable         record
array:float    array:program  boolean        hash           string
array:gtable   array:record   file           int            table
'''
        output_class = prompt_for_var('Class')
        use_completer()

        # Fill in the output parameter's JSON
        parameter_json = {
            "name": output_name,
            "class": output_class
            }
        program_json['outputSpec'].append(parameter_json)

if interpreter == 'python2.7':
    program_json['runSpec']['file'] = 'src/code.py'

print ''
print BOLD + '*** Generating DNAne' + CYAN + BOLD + 'x' + ENDC + BOLD + 'us App... ***' + ENDC

with open(os.path.join(name, 'dxprogram.json'), 'w') as prog_file:
    prog_file.write(json.dumps(program_json, indent=4) + '\n')
manifest.append(os.path.join(name, 'dxprogram.json'))

print ''
print textwrap.fill('''Your program specification has been written to the
dxprogram.json file. You can specify more program options by editing this file
directly (see http://develop.dnanexus.com/Developer-Portal for complete
documentation).''')
print ''
if input_spec and output_spec:
    with open(os.path.join(name, 'dxapp.json'), 'w') as app_file:
        app_file.write(json.dumps(app_json, indent=4) + '\n')
    manifest.append(os.path.join(name, 'dxapp.json'))

    print textwrap.fill('''Your app specification has been written to the
dxapp.json file. You can specify more app options by editing this file directly
(see http://develop.dnanexus.com/Developer-Portal for complete
documentation).''')
else:
    print textwrap.fill('''To auto-generate the app specification file
(dxapp.json), please re-run this wizard and provide specifications for your
app's inputs and outputs.''')
    print ''

for subdir in 'src', 'test', 'resources':
    try:
        os.mkdir(os.path.join(name, subdir))
        manifest.append(os.path.join(name, subdir, ''))
    except:
        sys.stderr.write("Unable to create subdirectory %s/%s" % (name, subdir))
        sys.exit(1)

if interpreter == 'python2.7':
    code_template = '''#!/usr/bin/env python
# {app_name} {app_version}
# Generated by dx_app_wizard.
# See http://develop.dnanexus.com/Building-Your-First-DNAnexus-App for instructions on how to modify this file.

import dxpy

@dxpy.entry_point('main')
def main({inputs}):
    # Please fill in your application code here.
    return {outputs}

dxpy.run()
'''
    test_template = '''#!/usr/bin/env python
# {app_name} {app_version} test suite
# Generated by dx_app_wizard.
# See http://develop.dnanexus.com/Building-Your-First-DNAnexus-App for instructions on how to modify this file.

import os, sys, unittest, json, subprocess

import dxpy, dxpy.program_builder
from dxpy.exceptions import *

src_dir = os.path.join(os.path.dirname(__file__), "..")
test_resources_dir = os.path.join(src_dir, "test", "resources")

def makeInputs():
    # Please fill in this method to generate default inputs for your app.
    return {{}}

class Test{app_name}(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.base_input = makeInputs()
        bundled_resources = dxpy.program_builder.upload_resources(src_dir)
        cls.program_id = dxpy.program_builder.upload_program(src_dir, bundled_resources, overwrite=True)
    
    def setUp(self):
        pass

    def tearDown(self):
        pass

    def test_base_input(self):
        job = dxpy.DXProgram(self.program_id).run(self.base_input)        
        print "Waiting for job to complete"
        job.wait_on_done()
        print json.dumps(job.describe()["output"])
'''

    inputs = []
    inputs_str = ''

    if "inputSpec" in program_json:
        # First, add all non-keyword args
        for input_param in program_json["inputSpec"]:
            if ("optional" in input_param and input_param['optional']) or "default" in input_param:
                continue
            inputs.append(input_param["name"]) 

        # Then, add keyword args
        for input_param in program_json["inputSpec"]:
            if ("optional" not in input_param or not input_param['optional']) and "default" not in input_param:
                continue
            if "default" in input_param:
                inputs.append("{name}={default}".format(name=input_param["name"], default=input_param["default"]))
            else:
                inputs.append("{name}=None".format(name=input_param["name"]))
        if len(inputs) > 0:
            inputs_str = ", ".join(inputs)
    else:
        inputs_str = "**kwargs"

    if "outputSpec" in program_json:
        outputs = {output["name"]: None for output in program_json["outputSpec"]}
    else:
        outputs = {}

    with open(os.path.join(name, 'src/code.py'), 'w') as code_file:
        code_file.write(code_template.format(app_name=name, app_version=version, inputs=inputs_str, outputs=outputs))
    subprocess.call(["chmod", "+x", os.path.join(name, 'src/code.py')])
    manifest.append(os.path.join(name, 'src/code.py'))

    with open(os.path.join(name, 'test/test.py'), 'w') as test_file:
        test_file.write(test_template.format(app_name=name, app_version=version, inputs=inputs_str, outputs=outputs))
    subprocess.call(["chmod", "+x", os.path.join(name, 'test/test.py')])
    manifest.append(os.path.join(name, 'test/test.py'))

print "Created files:"
for filename in manifest:
    print "\t", filename
print textwrap.fill('''App directory created! See http://develop.dnanexus.com/Building-Your-First-DNAnexus-App for
next steps, or run "dx_build_program %s".''' % name)
