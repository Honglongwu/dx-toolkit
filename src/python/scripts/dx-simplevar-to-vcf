#!/usr/bin/env python

import dxpy
import math
import argparse
import re

def main():

    parser = argparse.ArgumentParser(description='Download a Simplevar GTable as a VCF file.')
    parser.add_argument("--table_id", dest="simple_var_id", help="Simplevar gtable id to read from")
    parser.add_argument("-o", "--output", dest="file_name", help="Name of file to write VCF to")
    parser.add_argument("--quality_filter", dest="filter", type=int, default=0, help="What quality score filter to apply")
    parser.add_argument("--region", "-L", dest="region", action="append", help="Regions to pull mappings from in the format chr:lo-hi, useful for parallelization")
    parser.add_argument("--region_index_offset", dest="index_offset", type=int, default=0, help="For region arguments, shift the index by this amount (useful for converting from one-indexed to zero-indexed lists)")
    parser.add_argument("--export_minimal_columns", dest="export_minimal_columns", action="store_false" , help="Export more columns than the minimal simplevar set, if present")
    
    args = parser.parse_args()
    outputFile = open(args.file_name, 'w')
    writeAdditionalColumns = args.export_minimal_columns
    
    simpleVarTable = dxpy.open_dxgtable(args.simple_var_id)
    
    try:
        originalContigSet = simpleVarTable.get_details()['original_contigset']
    except:
        raise Exception("The original reference genome must be attached as a detail")
        
    contigDetails = dxpy.DXRecord(originalContigSet).get_details()
    dxpy.download_dxfile(contigDetails['flat_sequence_file']['$dnanexus_link'], 'ref.txt')
    
    header = simpleVarTable.get_details()['header']
    outputFile.write(header)
    
    chromosomeOffsets = {}
    for i in range(len(contigDetails['contigs']['names'])):
        chromosomeOffsets[contigDetails['contigs']['names'][i]] = contigDetails['contigs']['offsets'][i]


    contigSequence = open("ref.txt",'r').read()
    
    col = {}
    names = simpleVarTable.get_col_names()   
    for i in range(len(names)):
        col[names[i]] = i+1
    
    #refAppearsCompressed = False
    #noCallAppearsCompressed = False
    
    filter = args.filter
    
    if args.region != None:
        regions = parseRegions(args.region)
        for x in regions:
            query = simpleVarTable.genomic_range_query(chr=x[0][0],lo=int(x[0][1])+args.index_offset,hi=int(x[0][2])+args.index_offset,mode='overlap',index='gri')
            for row in simpleVarTable.iterate_query_rows(query=query):
                writeRow(row, col, filter, outputFile, writeAdditionalColumns, contigSequence, chromosomeOffsets)
    else:
        for row in simpleVarTable.iterate_rows():
            writeRow(row, col, filter, outputFile, writeAdditionalColumns, contigSequence, chromosomeOffsets)


def parseRegions(input):
    result = []
    for x in input:
        result.append(re.findall("(\w+):(\d+)-(\d+)", x))
    return result

def writeRow(row, col, filter, outputFile, writeAdditionalColumns, contigSequence, chromosomeOffsets):
    
    minimalColumns = ["chr", "lo", "hi", "type", "ref", "alt", "qual", "coverage", "genotypeQuality", "vcf_alt"]
    
    if row[col["type"]] != "no-call" and row[col["type"]] != "ref":
    
        chr = str(row[col["chr"]])
        pos = row[col["lo"]]+1
        ref = str(row[col["ref"]]).replace("-","")
        if row[col["type"]] != "No-call":
            if (row[col["type"]]) == "Ins" or (row[col["type"]]) == "Del" or (row[col["type"]]) == "Complex" or (row[col["type"]]) == "Mixed":
                ref = contigSequence[chromosomeOffsets[chr]+int(pos)]+ref
                pos += 1
            altOptions = row[col["alt"]].split("/")
            qual = str(row[col["qual"]])
            filter = "."
            vcfAlt = row[col["vcf_alt"]]
            vcfAdditional = row[col["vcf_additional_data"]]
            if row[3] != "Ref" and qual < filter:
                filter = "q"+str(filter)
            else:
                filter = "PASS"
                
            outputFile.write(chr+"\t"+str(pos)+"\t.\t"+ref+"\t"+vcfAlt+"\t"+qual+"\t"+filter)
            if writeAdditionalColumns:
                for k,v in col.iteritems():
                    if k not in minimalColumns:
                        outputFile.write("\t"+str(row[v]))
        outputFile.write("\n")

main()
